demo()
x=c(3,11,4,22,5)
above10=x>10
above10
x[above10]
cube <- function(x, n) {
x^3
}
cube(3)
x <- 1:10
if(x > 5) {
x <- 0
}
x <- 1:10
if(x[] > 5) {
x <- 0
}
x <- 1:10
if(x[ > 5) {
3
}
x <- 1:10
if(x[ > 5) {
c=3
}
x <- 1:10
if(x > 5) {
x <- 0
}
f <- function(x) {
g <- function(y) {
y + z
}
z <- 4
x + g(x)
}
z <- 10
f(3)
x <- 5
y <- if(x < 3) {
NA
} else {
10
}
x <- 5
y <- if(x < 3) {
NA
} else {
10
}
y <- if(x < 3) {
NA
} else {
10
}
y
args(paste)
paste("dss","33")
search()
rnorm(5)
x=list(a=matrix(1:4,2,2), b=matrix(1:6m3m2))
x=list(a=matrix(1:4,2,2), b=matrix(1:6,3,2))
a
$a
x$a
x[1]
x[2]
x$b
x$a[,1]
x$b[,1]
x$b[1,]
a = array(rnorm(2*2*10), c(2,2,10))
a
x=array(1:10,2,5)
x
y=array(1:10,c(2,5))
y
noise=function(n,mean,sd) {rnorm(n,mean,sd)}
mapply(noise,1:5,1:5,0.1)
mapply(noise,c(1,2,3,4,5),1:5,0.1)
mapply(noise,c(5,5,5,5,5),1:5,0.1)
mapply(noise,5:5,1:5,0.1)
mapply(noise,6:6,1:5,0.1)
mapply(noise,2:3,1:5,0.1)
mapply(noise,3:5,1:5,0.1)
mapply(noise,3:5,10:12,0.1)
x=c(rnorm(10),runif(10),rnorm(10,1))
x
f=gl(3,10)
f
tapply(x,f,mean)
tapply(x,f,max)
tapply(x,f,min)
tapply(x,f,range)
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
makeVector(1,2,1,2,1,2,1,2)
x=c(1,2,1,2)
makeVector(x)
cachemean(x)
mean(x)
mean(x)
set(1,2,3,4,5)
makeVector(set(1,2,3,4,5))
makeVector(setmean(1,2,3,4,5))
makeVector(set(x)
)
makeVector(set(x))
makeVector(get(x))
makeVector(get())
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
makeVector(set(x))
makeVector(get())
makeVector(get(x))
makeVector(2)
makeVector(3)
makeVector(4)
a=makeVector(c(1,2,3,4))
a
a$get()
a$setmean()
a$getmean()
cachemean
cachemean(a)
a$getmean()
a=2
traceback()
lm(y ~c)
traceback()
debug(lm)
lm(y ~c)
function (formula, data, subset, weights, na.action, method = "qr",
model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE,
contrasts = NULL, offset, ...)
{
ret.x <- x
read.csv("nofile")
library(datasets)
data(iris)
?iris
view(iris)
iris
iris[1:20,]
tapply(iris,Sepal.Length,mean)
tapply(iris,iris$Sepal.Length,mean)
tapply(iris$Sepal.Length,iris$Species,mean)
colMeans(iris)
apply(iris[, 1:4], 2, mean)
apply(iris[, 1:4], 1, mean)
colMeans(iris[1:4])
library(datasets)
data(mtcars)
?mtcars
with(mtcars, tapply(mpg, cyl, mean))
tapply(mtcars$cyl, mtcars$mpg, mean)
mtcars[1:20,]
lapply(mtcars, mean)
tapply(mtcars$hp, mtcars$cyl, mean)
tapply(mtcars$hp, mtcars$cyl, mean)[1]
tapply(mtcars$hp, mtcars$cyl, mean)[3]
tapply(mtcars$hp, mtcars$cyl, mean)[3]-tapply(mtcars$hp, mtcars$cyl, mean)[1]
debug(ls)
ls()
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
a=makeVector(1:10)
a$get()
a$set(2:11)
a$get()
a$getmean()
a$getmean()
a$setmean()
a$setmean(5)
a$getmean()
cachemean(a)
a$set(2:11)
cachemean(a)
a$set(2:11)
a$getmean()
cachemean(a)
a$getmean()
a$set(3:12)
a$getmean()
cachemean(a)
cachemean(a)
a$getmean()
a$getmean()
a$getmean()
median(x <- 1:10)
x
new_counter <- function() {
i <- 0
function() {
# do something useful, then ...
i <<- i + 1
i
}
}
counter_one  <- new_counter()
counter_one
counter_one()
counter_one()
counter_one()
counter_one()
counter_two  <- new_counter()
counter_two()
counter_two()
counter_one()
new_counte_mod <- function() {
i <- 0
function() {
# do something useful, then ...
i <- i + 1
i
}
}
a1 <- new_counte_mod()
a2 <- new_counte_mod()
a1()
a1()
a1()
a1()
con <- url("http://biostat.jhsph.edu/~jleek/contact.html")
htmlCode <- readLines(con)
close(con)
htmlCode
htmlCode[1:9]
nchar(htmlCode[10,20,30,100])
nchar(htmlCode[c(10,20,30,100)])
data1 <- read.csv("activity.csv")
#  What is mean total number of steps taken per day?
TotalStepsPerDay1 <- tapply(data1$steps, data1$date, sum, na.rm = TRUE)
hist(TotalStepsPerDay1, breaks =  ,col = "lightblue", main = "Sum of steps per day", xlab = "Sum of steps", ylab = "Frequency")
MeanStepsPerDay1 <- mean(TotalStepsPerDay1)
MedianStepsPerDay1 <- median(TotalStepsPerDay1)
# What is the average daily activity pattern?
AverageStepsPerInterval1 <- tapply(data1$steps,data1$interval, mean, na.rm = TRUE)
# -------------------------------------------------------------
data1$interval <- as.factor(data1$interval)
IntervalLevels <- levels(data1$interval)
plot(IntervalLevels, AverageStepsPerInterval1,  type="l", main = "Average steps per interval", xlab= "interval",
ylab= "steps", col="green" , lwd=2)
names(which.max(AverageStepsPerInterval1))
#  ------------------------------------------------------------------------------------------------------
# imputing missing values
#  calculating number of rows with NA values
#  create logical vector with that shows TRUE if row is complet or FALSE if NA is present
CompleteRows1 <- complete.cases(data1)
NumberofNARows1 <- length(CompleteRows1[CompleteRows1==FALSE])
#  using MICE package for imputation of missing values
#  you need to have library installed -
# install.packages("mice")
library(mice)
# to have repeatable results we need to set seed
set.seed(1)
vars.for.imputation = names(data1)
data2 = complete(mice(data1[vars.for.imputation]))
#  What is mean total number of steps taken per day?
TotalStepsPerDay2 <- tapply(data2$steps, data2$date, sum)
hist(TotalStepsPerDay2, breaks =  ,col = "lightblue", main = "Sum of steps per day", xlab = "Sum of steps", ylab = "Frequency")
MeanStepsPerDay2 <- mean(TotalStepsPerDay2)
MedianStepsPerDay2 <- median(TotalStepsPerDay2)
MeanStepsDifference <- MeanStepsPerDay2 - MeanStepsPerDay1
MedianStepsDifference <- MedianStepsPerDay2 - MedianStepsPerDay1
#  checking differences in activity patterns between weekdays and weekends
# data2$weekday <- weekdays(as.Date(data2$date))
# install.packages("chron")
library("chron")
for (i in 1:nrow(data2)) {
if(is.weekend(as.Date(data2$date[i]))) {
data2$DayType[i] <- "weekend"
} else {
data2$DayType[i] <- "weekday"
}
}
WeekdaysData <-  subset(data2, data2$DayType=="weekday")
setwd("C:/Users/212406928/RepData_PeerAssessment1")
ata1 <- read.csv("activity.csv")
#  What is mean total number of steps taken per day?
TotalStepsPerDay1 <- tapply(data1$steps, data1$date, sum, na.rm = TRUE)
hist(TotalStepsPerDay1, breaks =  ,col = "lightblue", main = "Sum of steps per day", xlab = "Sum of steps", ylab = "Frequency")
MeanStepsPerDay1 <- mean(TotalStepsPerDay1)
MedianStepsPerDay1 <- median(TotalStepsPerDay1)
# What is the average daily activity pattern?
AverageStepsPerInterval1 <- tapply(data1$steps,data1$interval, mean, na.rm = TRUE)
# -------------------------------------------------------------
data1$interval <- as.factor(data1$interval)
IntervalLevels <- levels(data1$interval)
plot(IntervalLevels, AverageStepsPerInterval1,  type="l", main = "Average steps per interval", xlab= "interval",
ylab= "steps", col="green" , lwd=2)
names(which.max(AverageStepsPerInterval1))
#  ------------------------------------------------------------------------------------------------------
# imputing missing values
#  calculating number of rows with NA values
#  create logical vector with that shows TRUE if row is complet or FALSE if NA is present
CompleteRows1 <- complete.cases(data1)
NumberofNARows1 <- length(CompleteRows1[CompleteRows1==FALSE])
#  using MICE package for imputation of missing values
#  you need to have library installed -
# install.packages("mice")
library(mice)
# to have repeatable results we need to set seed
set.seed(1)
vars.for.imputation = names(data1)
data2 = complete(mice(data1[vars.for.imputation]))
#  What is mean total number of steps taken per day?
TotalStepsPerDay2 <- tapply(data2$steps, data2$date, sum)
hist(TotalStepsPerDay2, breaks =  ,col = "lightblue", main = "Sum of steps per day", xlab = "Sum of steps", ylab = "Frequency")
MeanStepsPerDay2 <- mean(TotalStepsPerDay2)
MedianStepsPerDay2 <- median(TotalStepsPerDay2)
MeanStepsDifference <- MeanStepsPerDay2 - MeanStepsPerDay1
MedianStepsDifference <- MedianStepsPerDay2 - MedianStepsPerDay1
#  checking differences in activity patterns between weekdays and weekends
# data2$weekday <- weekdays(as.Date(data2$date))
# install.packages("chron")
library("chron")
for (i in 1:nrow(data2)) {
if(is.weekend(as.Date(data2$date[i]))) {
data2$DayType[i] <- "weekend"
} else {
data2$DayType[i] <- "weekday"
}
}
data1 <- read.csv("activity.csv")
#  What is mean total number of steps taken per day?
TotalStepsPerDay1 <- tapply(data1$steps, data1$date, sum, na.rm = TRUE)
hist(TotalStepsPerDay1, breaks =  ,col = "lightblue", main = "Sum of steps per day", xlab = "Sum of steps", ylab = "Frequency")
MeanStepsPerDay1 <- mean(TotalStepsPerDay1)
MedianStepsPerDay1 <- median(TotalStepsPerDay1)
# What is the average daily activity pattern?
AverageStepsPerInterval1 <- tapply(data1$steps,data1$interval, mean, na.rm = TRUE)
# -------------------------------------------------------------
data1$interval <- as.factor(data1$interval)
IntervalLevels <- levels(data1$interval)
plot(IntervalLevels, AverageStepsPerInterval1,  type="l", main = "Average steps per interval", xlab= "interval",
ylab= "steps", col="green" , lwd=2)
names(which.max(AverageStepsPerInterval1))
#  ------------------------------------------------------------------------------------------------------
# imputing missing values
#  calculating number of rows with NA values
#  create logical vector with that shows TRUE if row is complet or FALSE if NA is present
CompleteRows1 <- complete.cases(data1)
NumberofNARows1 <- length(CompleteRows1[CompleteRows1==FALSE])
#  using MICE package for imputation of missing values
#  you need to have library installed -
# install.packages("mice")
library(mice)
# to have repeatable results we need to set seed
set.seed(1)
vars.for.imputation = names(data1)
data2 = complete(mice(data1[vars.for.imputation]))
TotalStepsPerDay2 <- tapply(data2$steps, data2$date, sum)
hist(TotalStepsPerDay2, breaks =  ,col = "lightblue", main = "Sum of steps per day", xlab = "Sum of steps", ylab = "Frequency")
MeanStepsPerDay2 <- mean(TotalStepsPerDay2)
MedianStepsPerDay2 <- median(TotalStepsPerDay2)
MeanStepsDifference <- MeanStepsPerDay2 - MeanStepsPerDay1
MedianStepsDifference <- MedianStepsPerDay2 - MedianStepsPerDay1
#  checking differences in activity patterns between weekdays and weekends
# data2$weekday <- weekdays(as.Date(data2$date))
# install.packages("chron")
library("chron")
for (i in 1:nrow(data2)) {
if(is.weekend(as.Date(data2$date[i]))) {
data2$DayType[i] <- "weekend"
} else {
data2$DayType[i] <- "weekday"
}
}
WeekdaysData <-  subset(data2, data2$DayType=="weekday")
WeekdaysDataOrd <-  WeekdaysData[order(as.numeric(WeekdaysData$interval),StateHospitalData[,2]),]
WeekdaysDataOrd <-  WeekdaysData[order(as.numeric(WeekdaysData$interval),]
WeekdaysDataOrd <-  WeekdaysData[order(as.numeric(WeekdaysData$interval)),]
View(WeekdaysDataOrd)
View(WeekdaysDataOrd)
WeekdaysData <-  subset(data2, data2$DayType=="weekday")
WeekdaysData <-  WeekdaysData[order(as.numeric(WeekdaysData$interval)),]
WeekendData <-  subset(data2, data2$DayType=="weekend")
WeekendData <-  WeekendData[order(as.numeric(WeekendData$interval)),]
AvgStepsWeekday <- tapply(WeekdaysData$steps,WeekdaysData$interval, mean)
AvgStepsWeekend <- tapply(WeekendData$steps,WeekendData$interval, mean)
library(lattice)
WeekdaysData$interval <- as.factor(WeekdaysData$interval)
WeekdaysIntervalLevels <- levels(WeekdaysData$interval)
# plot(WeekdaysIntervalLevels, AvgStepsWeekday,  type="l", xlab= "interval", ylab= "steps", col="green" , lwd=2)
WeekendData$interval <- as.factor(WeekendData$interval)
WeekendIntervalLevels <- levels(WeekendData$interval)
# plot(WeekendIntervalLevels, AvgStepsWeekend,  type="l", xlab= "interval", ylab= "steps", col="red" , lwd=2)
WeekendAVGData <- data.frame(IntervalLevels = WeekendIntervalLevels,AvgSteps = AvgStepsWeekend, DayType = "weekend")
WeekdaysAVGData <- data.frame(IntervalLevels = WeekdaysIntervalLevels,AvgSteps = AvgStepsWeekday,DayType = "weekdays")
WeekAVGData <- rbind(WeekendAVGData,WeekdaysAVGData)
xyplot(AvgSteps ~ IntervalLevels | DayType, WeekAVGData,layout = c(1, 2), xlab = "interval", ylab = "steps",
main = "Average steps for weekdays and weekend")
plot(WeekAVGData$IntervalLevels, WeekAVGData$AvgSteps,  type="l", main = "Average steps per interval", xlab= "interval",
ylab= "steps", col="green" , lwd=2)
data1 <- read.csv("activity.csv")
#  What is mean total number of steps taken per day?
TotalStepsPerDay1 <- tapply(data1$steps, data1$date, sum, na.rm = TRUE)
hist(TotalStepsPerDay1, breaks =  ,col = "lightblue", main = "Sum of steps per day", xlab = "Sum of steps", ylab = "Frequency")
MeanStepsPerDay1 <- mean(TotalStepsPerDay1)
MedianStepsPerDay1 <- median(TotalStepsPerDay1)
# What is the average daily activity pattern?
AverageStepsPerInterval1 <- tapply(data1$steps,data1$interval, mean, na.rm = TRUE)
# -------------------------------------------------------------
data1$interval <- as.factor(data1$interval)
IntervalLevels <- levels(data1$interval)
plot(IntervalLevels, AverageStepsPerInterval1,  type="l", main = "Average steps per interval", xlab= "interval",
ylab= "steps", col="green" , lwd=2)
names(which.max(AverageStepsPerInterval1))
#  ------------------------------------------------------------------------------------------------------
# imputing missing values
#  calculating number of rows with NA values
#  create logical vector with that shows TRUE if row is complet or FALSE if NA is present
CompleteRows1 <- complete.cases(data1)
NumberofNARows1 <- length(CompleteRows1[CompleteRows1==FALSE])
#  using MICE package for imputation of missing values
#  you need to have library installed -
# install.packages("mice")
library(mice)
# to have repeatable results we need to set seed
set.seed(1)
vars.for.imputation = names(data1)
data2 = complete(mice(data1[vars.for.imputation]))
#  What is mean total number of steps taken per day?
TotalStepsPerDay2 <- tapply(data2$steps, data2$date, sum)
hist(TotalStepsPerDay2, breaks =  ,col = "lightblue", main = "Sum of steps per day", xlab = "Sum of steps", ylab = "Frequency")
MeanStepsPerDay2 <- mean(TotalStepsPerDay2)
MedianStepsPerDay2 <- median(TotalStepsPerDay2)
MeanStepsDifference <- MeanStepsPerDay2 - MeanStepsPerDay1
MedianStepsDifference <- MedianStepsPerDay2 - MedianStepsPerDay1
#  checking differences in activity patterns between weekdays and weekends
# data2$weekday <- weekdays(as.Date(data2$date))
# install.packages("chron")
library("chron")
for (i in 1:nrow(data2)) {
if(is.weekend(as.Date(data2$date[i]))) {
data2$DayType[i] <- "weekend"
} else {
data2$DayType[i] <- "weekday"
}
}
data2$DayType <- as.factor(data2$DayType)
data3 <- aggregate(steps ~ interval + DayType, data = data2, mean)
View(data3)
View(data3)
xyplot(steps ~ interval | DayType, stepsByDay, type = "l", layout = c(1, 2),
xlab = "Interval", ylab = "Number of steps")
xyplot(steps ~ interval | DayType, data3, type = "l", layout = c(1, 2),
xlab = "Interval", ylab = "Number of steps")
?aggregate
library(knitr)
setwd("C:/Users/212406928/RepData_PeerAssessment1")
knit2html("PA1_template.html")
knit2html("PA1_template.Rmd")
